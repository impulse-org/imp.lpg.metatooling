%options package=$PACKAGE_NAME$
%options template=$TEMPLATE$
%options import_terminals=$CLASS_NAME_PREFIX$Lexer.gi
$AUTO_GENERATE$
--
-- This is just a sample grammar and not a real grammar for $LANG_NAME$
--

$Globals
    /.import org.eclipse.uide.parser.IParser;
      import org.eclipse.uide.editor.IMessageHandler;	// SMS 30 Aug 2006
    ./
$End


-- SMS 30 Aug 2006:  Added headers section
$Headers
	/.
        
        private IMessageHandler msgHandler;

	public void setMessageHandler(IMessageHandler handler) {
	    msgHandler= handler;
	}
	
	public void reportError(int errorCode, String locationInfo, int leftToken, int rightToken, String tokenText)
	{
	    int len= getEndOffset(rightToken) - getStartOffset(leftToken) + 1;
	    if (msgHandler != null)
	      msgHandler.handleMessage(getStartOffset(leftToken), len, errorMsgText[errorCode]);
	}
 
	./
$End


$Define
    $ast_class /.Object./
    $additional_interfaces /., IParser./
$End

$Terminals
    --            
    -- Here, you may list terminals needed by this grammar.
    -- Furthermore, a terminal may be mapped into an alias
    -- that can also be used in a grammar rule. In addition,
    -- when an alias is specified here it instructs the
    -- generated parser to use the alias in question when
    -- referring to the symbol to which it is aliased. For
    -- example, consider the following definitions:
    --
         int
         short
         IDENTIFIER 
         NUMBER
         SEMICOLON ::= ';'
         PLUS ::= '+'
         MINUS ::= '-'
         ASSIGN ::= '='
         LEFTBRACE ::= '{'
         RIGHTBRACE ::= '}'
    --
    -- Here the terminals int, float, IDENTIFIER and NUMBER are
    -- defined without an alias; SEMICOLON is aliased to ';';
    -- PLUS is aliased to '+'... etc...
    --
    -- Note that the terminals that do not have aliases are declared
    -- above only for documentation purposes.
    --
$End

$Start
    Program
$End


$Rules
    -- In this section you list all the rules for your grammar.
    -- When reduced, each rule will produce one Ast node.
    -- 
    --  Here are some example rules:
    -- 
    
    	Program ::= stmtList
    
        stmtList$$statement ::= $empty
                | stmtList statement
        statement ::= declaration
                    | assignment
                    | block
    	block ::= LEFTBRACE stmtList RIGHTBRACE
        declaration ::= int identifier ;
                      | short identifier ;
        assignment ::= identifier '=' expression ';'
        expression ::= expression '+' term
                     | expression '-' term
                     | term
        term ::= identifier
               | NUMBER
        identifier ::= IDENTIFIER
    -- 
$End
