package $PKG$;

//////////////////////////////////////////////////////////////////
//                                                              //
//  This file was auto-generated by the LPG Eclipse Tooling.    //
//  It is safe to edit this file. It will not be overwritten.   //
//                                                              //
//////////////////////////////////////////////////////////////////

import java.util.ArrayList;

import org.eclipse.uide.parser.IToken;
import org.jikes.lpg.runtime.TokenStream;

//
// LexStream holds an arraylist of tokens scanned 
// from the input stream by Scanner.java
//
public class LexStream implements TokenStream {
    public int index = 0;

    public int len = 0;

    public CharStream charStream;

    public ArrayList tokens;

    public LexStream(CharStream charStream) {
        this.charStream = charStream;
        tokens = new ArrayList(5000);
        addBadToken();
    }

    public void addToken(Token token) {
        tokens.add(token);
    }

    public void addBadToken() {
        tokens.add(new Token());
    }

    public String getTokenText(int tokenNumber) {
        Token t = (Token) tokens.get(tokenNumber);
        return t.toString(charStream.inputChars);
    }

    public int getStartOffset(int tokenNumber) {
        Token t = (Token) tokens.get(tokenNumber);
        return t.startOffset;
    }

    public int getEndOffset(int tokenNumber) {
        Token t = (Token) tokens.get(tokenNumber);
        return t.endOffset;
    }

    public int getTokenLength(int tokenNumber) {
        Token t = (Token) tokens.get(tokenNumber);
        return t.endOffset - t.startOffset + 1;
    }

    public int getLineNumberOfTokenAt(int tokenNumber) {
        Token t = (Token) tokens.get(tokenNumber);
        return charStream.getLineNumberOfCharAt(t.endOffset);
    }

    public int getLineNumber(int offset) {
        return charStream.getLineNumberOfCharAt(offset);
    }

    public int getColumnOfTokenAt(int tokenNumber) {
        Token t = (Token) tokens.get(tokenNumber);
        return charStream.getColumnOfCharAt(t.startOffset);
    }

    public int getEndColumnOfTokenAt(int tokenNumber) {
        Token t = (Token) tokens.get(tokenNumber);
        return charStream.getColumnOfCharAt(t.endOffset);
    }

    public char[] getInputChars() {
        return charStream.getInputChars();
    }

    public int getSize() {
        return tokens.size();
    }

    public Token getTokenAt(int tokenNumber) {
        return (Token) tokens.get(tokenNumber);
    }

    public ArrayList getTokens() {
        return tokens;
    }

    public int getStreamIndex() {
        return index;
    }

    public int getStreamLength() {
        return len;
    }

    public void setStreamIndex(int index) {
        this.index = index;
    }

    public void setStreamLength(int len) {
        this.len = len;
    }

    public CharStream getCharStream() {
        return charStream;
    }

    public void dumpTokens() {
        System.out.println(" Kind \t Offset  Line \t Col \t Len  \tText\n");
        for (int index = 1; index < getSize(); index++)
            dumpToken(index);
    }

    public void dumpToken(int tokenNumber) {
        System.out.print(" (" + getKind(tokenNumber) + ")\t : ");
        System.out.print(getStartOffset(tokenNumber));
        System.out.print(" \t " + getLineNumberOfTokenAt(tokenNumber));
        System.out.print(" \t " + getColumnOfTokenAt(tokenNumber));
        System.out.print(" \t " + getTokenLength(tokenNumber));
        System.out.print("    \t\"" + getTokenText(tokenNumber) + "\"");
        System.out.println();
    }

    public int next(int tokenNumber) {
        return (++tokenNumber < len ? tokenNumber : len - 1);
    }

    public int previous(int tokenNumber) {
        return (tokenNumber <= 0 ? 0 : tokenNumber - 1);
    }

    // Methods that implement the TokenStream Interface
    //
    //
    public int getToken() {
        return index = next(index);
    }

    public int getToken(int end_token) {
        index = (index < end_token ? next(index) : len - 1);
        return index;
    }

    public int getKind(int tokenNumber) {
        Token t = (Token) tokens.get(tokenNumber);
        return t.kind;
    }

    public int getNext(int tokenNumber) {
        return (++tokenNumber < len ? tokenNumber : len - 1);
    }

    public int getPrevious(int tokenNumber) {
        return (tokenNumber <= 0 ? 0 : tokenNumber - 1);
    }

    public String getName(int tokenNumber) {
        return getTokenText(tokenNumber);
    }

    public int peek() {
        return next(index);
    }

    public void reset(int tokenNumber) {
        index = previous(tokenNumber);
    }

    public void reset() {
        index = 0;
    }

    public int badToken() {
        return 0;
    }

    public int getLine(int tokenNumber) {
        return getLineNumberOfTokenAt(tokenNumber);
    }

    public int getColumn(int tokenNumber) {
        return getColumnOfTokenAt(tokenNumber);
    }

    public int getEndLine(int tokenNumber) {
        return getLine(tokenNumber);
    }

    public int getEndColumn(int tokenNumber) {
        return getEndColumnOfTokenAt(tokenNumber);
    }

    public boolean afterEol(int tokenNumber) {
        return (tokenNumber < 1 ? true
                : getLineNumberOfTokenAt(tokenNumber - 1) < getLineNumberOfTokenAt(tokenNumber));
    }

    public String getFileName() {
        return charStream.getFileName();
    }

    public void reportError(int tokenNumber, String code) {
        if (code.equalsIgnoreCase("BadParseSymFileException")) {
            System.out
                    .println("****Parse Symbol File is not valid for parsing ");
        } else {
            System.out.println("****" + code + " " + tokenNumber);
            dumpToken(tokenNumber);
        }
    }

    public void reportError(String tokenText, int tokenNumber) {
        charStream.reportError(tokenText, (IToken) tokens.get(tokenNumber));
    }

    public void reportError(int errorCode, String locationInfo, String tokenText) {
    }

    public void reportError(int errorCode, String locationInfo, int leftToken,
            int rightToken, String tokenText) {
        charStream.reportError(tokenText, (IToken) tokens.get(leftToken));
    }

    public void addEofToken(int eofKind) {
        Token token = new Token();
        token.startOffset = charStream.getStreamIndex();
        token.endOffset = charStream.getStreamIndex();
        token.kind = eofKind;
        addToken(token);
        len = tokens.size();
    }

    public boolean isValidForParser() {
        return charStream.isValidForParser();
    };

    public Token getTokenAtCharacter(int characterIndex) {
        int tokenIndex = binarySearch(0, tokens.size() - 1, characterIndex);
        if (tokenIndex != -1) {
            Token result = (Token) tokens.get(tokenIndex);
            if (characterIndex <= result.endOffset)
                return result;
        }
        return null;
    }

    public int binarySearch(int i, int n, int characterIndex) {
        if (n == 0)
            return -1;
        if (n == 1)
            return i;
        int j = i + n / 2;
        Token token = (Token) tokens.get(j);
        if (token.startOffset <= characterIndex)
            return binarySearch(j, n - n / 2, characterIndex);
        else
            return binarySearch(i, n / 2, characterIndex);
    };

    public int getTokenIndexAtCharacter(int characterIndex) {
        return binarySearch(0, tokens.size() - 1, characterIndex);
    }

}
