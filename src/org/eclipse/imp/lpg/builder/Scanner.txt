package $PKG$;

//////////////////////////////////////////////////////////////////
//                                                              //
//  This file was auto-generated by the LPG Eclipse Tooling.   //
//  It is safe to edit this file. It will not be overwritten.  //
//                                                              //
//////////////////////////////////////////////////////////////////


import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;

import org.eclipse.uide.parser.IToken;

/**
 * Scan an input stream and turn it into a list of tokens.
 *
 * @author Chris Laffra 
 */
public class Scanner extends AbstractScanner {

    protected char nextChar;

    protected char contents[];

    protected int index = -1;

    public LexStream lexStream;

    public CharStream charStream;

    public String fileName;

    public Scanner() {
    }

    public char getChar() {
        try {
            char c = contents[++index];
            if (c == '\n')
                charStream.setLineOffset(index);
            return c;
        } catch (Exception e) {
            return '\uffff';
        }
    }

    public char peekChar(int offset) {
        try {
            return contents[index + offset];
        } catch (Exception e) {
            return '\uffff';
        }
    }

    public char getChar(int offset) {
        try {
            return contents[offset];
        } catch (Exception e) {
            return '\uffff';
        }
    }

    public int getLineNumberOfTokenAt(int tokenNumber) {
        return charStream.getLineNumberOfCharAt(tokenNumber);
    }

    public int getLineNumber(int offset) {
        return charStream.getLineNumberOfCharAt(offset);
    }

    public void skip_spaces() throws java.io.IOException {
        while (nextChar != '\uffff'
                && (nextChar == ' ' || nextChar == '\t' || nextChar == '\n' || nextChar == '\r')) {
            try {
                nextChar = contents[++index];
                if (nextChar == '\n')
                    charStream.setLineOffset(index);
            } catch (Exception e) {
                nextChar = '\uffff';
            }
        }
    }

    // TODO: add support for skipping comments in the scanner
    public Token getNextToken() throws java.io.IOException {
        while (nextChar != '\uffff'
                && (nextChar == ' ' || nextChar == '\t' || nextChar == '\n' || nextChar == '\r')) {
            try {
                nextChar = contents[++index];
                if (nextChar == '\n')
                    charStream.setLineOffset(index);
            } catch (Exception e) {
                nextChar = '\uffff';
            }
        }
        int start = index;
        for (int n = 0; n < KEYWORDS.length; n++) {
            char keyword[] = KEYWORDS[n];
            int length = keyword.length;
            int offset = index;
            boolean isKeyword = true;
            for (int k = 0; isKeyword && k < length; k++) {
                char c = offset < contents.length ? contents[offset++]
                        : '\uffff';
                if (keyword[k] != c) // not a match
                    isKeyword = false;
            }
            if (isKeyword) {
                char c = offset < contents.length ? contents[offset] : '\uffff';
                if (c >= '0' && c <= '9' || c >= 'A' && c <= 'Z' || c >= 'a'
                        && c <= 'z' || c == '_') {
                    isKeyword = false;
                }
            }
            if (isKeyword) {
                Token token = new Token();
                token.startOffset = start;
                token.endOffset = index + length - 1;
                token.kind = KEYWORD_VALUES[n];
                index += length;
                nextChar = index < contents.length ? contents[index] : '\uffff';
                return token;
            }
        }
        while (nextChar != '\uffff'
                && !(nextChar == ' ' || nextChar == '\t' || nextChar == '\n' || nextChar == '\r')) {
            char c = nextChar;
            try {
                nextChar = contents[++index];
                if (nextChar == '\n')
                    charStream.setLineOffset(index);
            } catch (Exception e) {
                nextChar = '\uffff';
            }
            ;
            // TODO: check if this is the right way to scan tokens
            if (!(c >= '0' && c <= '9' || c >= 'A' && c <= 'Z' || c >= 'a'
                    && c <= 'z' || c == '_')) {
                c = nextChar;
                if (!(c >= '0' && c <= '9' || c >= 'A' && c <= 'Z' || c >= 'a'
                        && c <= 'z' || c == '_')) {
                    break;
                }
            }
        }
        Token token = new Token();
        token.startOffset = start;
        token.endOffset = index - 1;
        token.kind = IDENTIFIER;
        return token;
    }

    public boolean isKeyword(IToken someToken) {
        Token token = (Token) someToken;
        return token.kind != IDENTIFIER;
    }

    public boolean isSpace(IToken token) {
        for (int k = token.getStartOffset(); k <= token.getEndOffset(); k++) {
            if (!Character.isSpaceChar(contents[k])) // not a space
                return false;
        }
        return true;
    }

    public LexStream scan(String fileName) throws java.io.IOException {
        contents = read(fileName);
        return scan(fileName, contents);
    }

    public LexStream scan(String fileName, char chars[])
            throws java.io.IOException {
        //
        // Do not use token indexed at location 0.
        //
        contents = chars;
        this.fileName = fileName;
        charStream = new CharStream(fileName, contents);
        lexStream = new LexStream(charStream);
        nextChar = getChar();
        while (nextChar != '\uffff') {
            Token token = getNextToken();
            if (token != null)
                lexStream.addToken(token);
        }
        lexStream.addEofToken($eof);
        return lexStream;
    }

    public static char[] read(String fileName) throws IOException {
        File file = new File(fileName);
        int len = (int) file.length();
        BufferedReader in = new BufferedReader(new InputStreamReader(
                new FileInputStream(file)));
        char result[] = new char[len + 2];
        in.read(result, 0, len);
        result[len] = '\n'; // Ensure input is terminated with the new line char
        result[len + 1] = '\uffff'; // followed by an end of file character
        return result;

    }

}

//////////////////////////////////////////////////////////////////
//                                                              //
//   This file was auto-generated by the LPG Eclipse Tooling.   //
//   It is safe to edit this file. It will not be overwritten.  //
//                                                              //
//////////////////////////////////////////////////////////////////
