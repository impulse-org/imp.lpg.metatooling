package $PKG$;

//////////////////////////////////////////////////////////////////
//                                                              //
//                 IMPORTANT WARNING                            //
//                                                              //
//   This file was auto-generated by the LPG Eclipse Tooling.   //
//       Do not edit this file. It will be overwritten.         //
//                                                              //
//////////////////////////////////////////////////////////////////
	
import java.io.IOException;
import java.util.HashSet;

import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.uide.core.ILanguageService;
import org.eclipse.uide.parser.Ast;
import org.eclipse.uide.parser.IModel;
import org.eclipse.uide.parser.IParser;
import org.eclipse.uide.parser.IToken;
import org.eclipse.uide.parser.ParseError;
import org.jikes.lpg.runtime.BacktrackingParser;
import org.jikes.lpg.runtime.BadParseException;
import org.jikes.lpg.runtime.BadParseSymFileException;
import org.jikes.lpg.runtime.DiagnoseParser;
import org.jikes.lpg.runtime.LpgParser;
import org.jikes.lpg.runtime.ParseTable;
import org.jikes.lpg.runtime.RuleAction;

/**
 * Basic parser. Each production will create an Ast node, resulting in a
 * concrete parse tree. 
 * 
 * @author Chris Laffra
 */
public abstract class AbstractParser implements RuleAction, IParser, ILanguageService {
    public boolean DEBUG    = false; 
    public boolean DIAGNOSE = true;
    public boolean FLATTEN  = true;

    public LexStream prsStream;

    public ParseTable prs;

    public Scanner scanner;

    public HashSet astNodesToIgnore = getAstNodesToIgnore();

    public Model result;

    public LpgParser lpgParser;

    public String language;


    /**
     *  Instruct the parser to print debug messages or not
     */
    public void setDebug(boolean value) {
        DEBUG = value;
    }
    
    /**
     *  Control whether this parser should go into diagnosing mode to find more details when it detects a syntax error. 
     *  Diagnosing  generates more detailed errors, but can be expensive.
     */
    public void setDiagnose(boolean value) {
        DIAGNOSE = value;   
    }
    
    /**
     *  Control whether the parser should automatically flatten AST nodes when adding them to the parse tree. 
     */ 
    public void setFlatten(boolean value) {
        FLATTEN  = value;
    }

    /**
     * Return a list of rules to be flattened when creating the AST
     */
    public abstract HashSet getAstNodesToIgnore();

    public void setLanguage(String language) {
        this.language = language;
    }

    public boolean shouldIgnoreNode(String ruleName) {
        return astNodesToIgnore.contains(ruleName);
    }

    public boolean shouldFlatten() {
        return FLATTEN;
    }

    public AbstractParser() {
    }

    public LpgParser createParser(String contents)
            throws BadParseSymFileException, IOException {
        this.scanner = new Scanner();
        this.prsStream = scanner
                .scan("Editor Contents", contents.toCharArray());
        this.prs = new $LNG$prs();
        return new BacktrackingParser(prsStream, prs, this);
    }

    public IModel parse(String contents, boolean scanOnly,
            IProgressMonitor monitor) {
        result = new Model();
        try {
            result.parser = this;
            // create the parser, which will tokenize the contents
            lpgParser = createParser(contents);
        } catch (Exception e) {
            e.printStackTrace();
            return result;
        }
        if (scanOnly)
            return result;
        try {
            result.ast = lpgParser.parse(monitor);
            if (prsStream.index < prsStream.tokens.size() - 1) {
                ParseError error = new ParseError("Unexpected EOF at token "
                        + prsStream.index, prsStream
                        .getTokenAt(prsStream.index));
                result.errors.add(error);
            }
        } catch (BadParseException e) {
            IToken errorToken = prsStream.getTokenAt(e.error_token);
            if (errorToken.getKind() == $LNG$sym.$eof) {
                result.errors.add(new ParseError(
                        "Unexpected End Of File around token "
                                + (e.error_token), errorToken));
                if (e.error_token < prsStream.tokens.size() - 1) {
                    result.errors.add(new ParseError(
                            "Internal Parser error, token " + e.error_token
                                    + ", not recognized by scanner.",
                            errorToken));
                }
            } else {
//              int startOffset = errorToken.getStartOffset();
//              int endOffset = errorToken.getEndOffset();
                String tokenKindName = errorToken.getTokenKindName();
                String value = result.getString(errorToken);
                result.errors.add(new ParseError("Syntax error on \"" + value
                        + "\" kind=" + tokenKindName, errorToken));
                if (DIAGNOSE) {
                    DiagnoseParser errorDiagnoser = new DiagnoseParser(
                            prsStream, prs);
                    errorDiagnoser.diagnose(prsStream.tokens
                            .indexOf(errorToken), 25);
                }
                for (int n = 0; n < prsStream.charStream.errors.size(); n++) {
                    result.errors.add(prsStream.charStream.errors.get(n));
                }
            }
        }
        return result;
    }

    public void ruleAction(int ruleNumber) {
 
