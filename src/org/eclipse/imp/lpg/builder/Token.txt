package $PKG$;

import org.eclipse.uide.parser.Ast;
import org.eclipse.uide.parser.IToken;

//////////////////////////////////////////////////////////////////
//                                                              //
//                 IMPORTANT WARNING                            //
//                                                              //
//   This file was auto-generated by the LPG Eclipse Tooling.   //
//       Do not edit this file. It will be overwritten.         //
//                                                              //
//////////////////////////////////////////////////////////////////

/**
 * Tokens are generated by the scanner when the input is read.
 * Tokens don't contain any string values, just indices to the original input char array
 * Tokens have an associated Ast node, which is useful for content assist, etc.
 * LexStream has support to find the token under a given character offset.
 *
 * Based on the LEG examples shipped with JikesPG
 *
 * @see $PKG$.LexStream#getTokenAtCharacter(int)
 * @author Chris Laffra 
 */
public class Token implements $LNG$sym, IToken {
    public int kind = 0;
    public int startOffset = 0;
    public int endOffset = 0;
    public Ast ast;

    public Token() {
    }
    public Ast getAst() { return ast; }
    public void setAst(Ast ast) {
        this.ast = ast;
    }
    public int getStartOffset() { return startOffset; }
    public int getEndOffset() { return endOffset; }
    public void setStartOffset(int offset) { startOffset = offset; }
    public void setEndOffset(int offset) { endOffset = offset; }
    public String toString() {
        throw new InternalError("Unimplemented Method");
    }
    public String toString(Scanner scanner) {
        return toString(scanner.contents);
    }
    public String toString(char contents[]) {
        try {
            int len = endOffset - startOffset + 1;
            if (startOffset == -1) return "<EOF>";
            return new String(contents, startOffset, len);
        }
        catch (Exception e) {
            if (contents == null)
                return "Internal Error: token "+getTokenKindName()+" endOffset="+endOffset+" contents=null";
            else
                return "Internal Error: token "+getTokenKindName()+" endOffset="+endOffset+" contents.length="+contents.length;
        }
    }
    public boolean equals(char[] contents, String string) {
        int len = string.length();
        if (endOffset - startOffset + 1 != len) return false;
        for (int n=0, k=startOffset; n<len; n++, k++)
            if (string.charAt(n) != contents[k]) 
                return false;
        return true;
    }
    public boolean equalsIgnoreCase(char[] contents, String string) {
        int len = string.length();
        if (endOffset - startOffset + 1 != len) return false;
        for (int n=0, k=startOffset; n<len; n++, k++)
            if (string.charAt(n) != Character.toLowerCase(contents[k])) 
                return false;
        return true;
    }
    public int getKind() {
        return kind;
    }
    public String getTokenKindName() {
        if (kind == -1) return "[-1]";
        return tokenNames[kind];
    }