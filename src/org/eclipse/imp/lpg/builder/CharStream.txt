package $PKG$;

//////////////////////////////////////////////////////////////////
//                                                              //
//   This file was auto-generated by the LPG Eclipse Tooling.   //
//   It is safe to edit this file. It will not be overwritten.  //
//                                                              //
//////////////////////////////////////////////////////////////////

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import org.eclipse.uide.parser.IToken;
import org.eclipse.uide.parser.ParseError;
import org.jikes.lpg.runtime.ParseErrorCodes;
import org.jikes.lpg.runtime.TokenStream;

//
//CharStream contains an array of characters as the input stream to be parsed.
//There are methods to retrieve and classify characters.
//The lexparser "token" is implemented simply as the index of the next character in the array.
//
public class CharStream implements TokenStream, LexerSymbols, TokenKindMap, ParseErrorCodes {
    public int index = -1;

    public int len = 0;

    public char[] inputChars;

    public int line = -1;

    public int[] lineOffsets; // an array of end of line offsets

    public int newLength = 0;

    public final static int INITIAL = 4000;

    public String fileName;

    public List errors;

    CharStream() {
        errors = new ArrayList();
    }

    public CharStream(String fileName, char inputChars[]) {
        this();
        this.fileName = fileName;
        this.inputChars = inputChars;
        len = inputChars.length;
        index = -1; // ensure the start index is -1
        // inputChars[len - 2] = '\n'; // Ensure input is terminated with the
        // new line char
        // inputChars[len - 1] = '\uffff'; // ensure an end of file is present
        setLineOffset(-1); // initialize line offset array
    }

    char getCharValue(int i) {
        return inputChars[i];
    }

    public int getLine() {
        return line + 1;
    }

    int getLineNumberOfCharAt(int i) {
        int index = Arrays.binarySearch(lineOffsets, i);
        return index < 0 ? -index - 1 : index < 1 ? 1 : index - 1;
    }

    int getColumnOfCharAt(int i) {
        int lineNo = getLineNumberOfCharAt(i);
        return i - lineOffsets[lineNo - 1];
    }

    int getStreamIndex() {
        return index;
    }

    int getStreamLength() {
        return len;
    }

    void setStreamIndex(int index) {
        this.index = index;
    }

    void setStreamLength(int len) {
        this.len = len;
    }

    public char[] getInputChars() {
        return inputChars;
    }

    void setLineOffset(int i) {
        line++;
        if (line >= newLength) {
            reallocateLineOffsetsArray();
        }
        lineOffsets[line] = i;
    }

    void reallocateLineOffsetsArray() {
        int oldLength = (lineOffsets == null ? 0 : newLength);

        if (oldLength == 0) {
            newLength = INITIAL;
            lineOffsets = new int[newLength];
        } else {
            newLength = oldLength + oldLength;
            System.arraycopy(lineOffsets, 0, lineOffsets = new int[newLength],
                    0, oldLength);
        }
        Arrays.fill(lineOffsets, oldLength, newLength - 1, Integer.MAX_VALUE);
        return;
    }

    int next(int i) {
        return (++i < len ? i : len - 1);
    }

    int previous(int i) {
        return (i <= 0 ? 0 : i - 1);
    }

    // Methods that implement the TokenStream Interface
    //
    //

    public int getToken() {
        index = next(index);
        char c = inputChars[index];
        if (c > 32) {
            return index;
        }
        if (c == 10) {
            setLineOffset(index);
            return index;
        } // a line feed '\n'

        for (;; index = next(index)) {
            c = inputChars[next(index)];
            if (c > 32 || c == 10)
                break;
        }
        return index;
    }

    public int getToken(int end_token) {
        return index = (index < end_token ? next(index) : len - 1);
    }

    public int getKind(int i) {
        char c = inputChars[i];

        if (c < 128) // ASCII Character
        {
            return tokenKind[c];
        } else if (c == '\uffff') {
            return Char_EOF;
        } else {
            return Char_AfterASCII;
        }
    }

    public int getNext(int i) {
        return (++i < len ? i : len - 1);
    }

    public int getPrevious(int i) {
        return (i <= 0 ? 0 : i - 1);
    }

    public String getName(int i) {
        return Character.toString(getCharValue(i));
    }

    public int peek() {
        return next(index);
    }

    public void reset(int i) {
        index = previous(i);
    }

    public void reset() {
        index = -1;
    }

    public int badToken() {
        return 0;
    }

    public int getLine(int i) {
        return getLineNumberOfCharAt(i);
    }

    public int getColumn(int i) {
        return getColumnOfCharAt(i);
    }

    public int getEndLine(int i) {
        return getLine(i);
    }

    public int getEndColumn(int i) {
        return getColumnOfCharAt(i);
    }

    public boolean afterEol(int i) {
        return (i < 1 ? true
                : getLineNumberOfCharAt(i - 1) < getLineNumberOfCharAt(i));
    }

    public String getFileName() {
        return fileName;
    }

    public void reportError(String errorText, int token) {
    }

    public void reportError(String tokenText, IToken token) {
        errors.add(new ParseError(tokenText, token));
    }

    public boolean isValidForParser() {
        return $LNG$sym.isValidForParser;
    };

    public void reportError(int errorCode, String locationInfo, int leftToken, int rightToken, String tokenText) {
    }
    
    public void reportError(int i, String code) {
    }

    public void reportError(int errorCode, String locationInfo, String tokenText) {
    };

}
